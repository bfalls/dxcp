name: Build Demo Artifacts

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - demo-service/**
      - demo-service-2/**
      - scripts/publish_build.sh

permissions:
  contents: write

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Fetch git tags
        shell: bash
        run: git fetch --tags --force

      - name: Determine changed services
        id: changed
        shell: bash
        run: |
          set -euo pipefail
          before_sha="${{ github.event.before }}"
          if [[ -z "$before_sha" || "$before_sha" == "0000000000000000000000000000000000000000" ]]; then
            before_sha="$(git rev-list --max-parents=0 HEAD | tail -n1)"
          fi
          changed_files="$(git diff --name-only "$before_sha" "${GITHUB_SHA}" || true)"
          echo "$changed_files"

          services=()
          while IFS= read -r candidate; do
            [[ -z "$candidate" ]] && continue
            if [[ -d "$candidate" && -f "$candidate/app.py" && -f "$candidate/lambda_handler.py" ]]; then
              services+=("$candidate")
            fi
          done < <(
            printf "%s\n" "$changed_files" \
              | awk -F/ '/^(demo-service|demo-service-2)\// {print $1}' \
              | sort -u
          )

          if [[ "${#services[@]}" -eq 0 ]]; then
            echo "No demo service changes detected; skipping publish."
            echo "services=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "services=${services[*]}" >> "$GITHUB_OUTPUT"

      - name: Build and publish changed demo service artifacts
        id: publish
        if: steps.changed.outputs.services != ''
        env:
          DXCP_ARTIFACT_BUCKET: ${{ vars.DXCP_ARTIFACT_BUCKET }}
        shell: bash
        run: |
          set -euo pipefail
          published_manifest="${RUNNER_TEMP}/dxcp-published-builds.tsv"
          : > "$published_manifest"

          latest_semver_from_tag() {
            local service="$1"
            local best=""
            while IFS= read -r tag; do
              [[ -z "$tag" ]] && continue
              if [[ "$tag" =~ ^${service}/v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
                local semver="${BASH_REMATCH[1]}"
                if [[ -z "$best" ]] || [[ "$(printf "%s\n%s\n" "$best" "$semver" | sort -V | tail -n1)" == "$semver" ]]; then
                  best="$semver"
                fi
              fi
            done < <(git tag -l "${service}/v*")
            if [[ -n "$best" ]]; then
              echo "$best"
            fi
          }

          latest_semver_from_s3() {
            local service="$1"
            local best_major=""
            local best_minor=""
            local best_patch=""
            local keys
            keys="$(aws s3api list-objects-v2 \
              --bucket "$DXCP_ARTIFACT_BUCKET" \
              --prefix "${service}/${service}-" \
              --query 'Contents[].Key' \
              --output text 2>/dev/null || true)"
            for key in $keys; do
              local file_name="${key##*/}"
              if [[ "$file_name" =~ ^${service}-([0-9]+)\.([0-9]+)\.([0-9]+)([-+][A-Za-z0-9._-]+)?\.zip$ ]]; then
                local k_major="${BASH_REMATCH[1]}"
                local k_minor="${BASH_REMATCH[2]}"
                local k_patch="${BASH_REMATCH[3]}"
                if [[ -z "$best_major" ]] \
                  || (( k_major > best_major )) \
                  || (( k_major == best_major && k_minor > best_minor )) \
                  || (( k_major == best_major && k_minor == best_minor && k_patch > best_patch )); then
                  best_major="$k_major"
                  best_minor="$k_minor"
                  best_patch="$k_patch"
                fi
              fi
            done
            if [[ -n "$best_major" && -n "$best_minor" && -n "$best_patch" ]]; then
              echo "${best_major}.${best_minor}.${best_patch}"
            fi
          }

          bump_patch() {
            local current="$1"
            if [[ "$current" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              local major="${BASH_REMATCH[1]}"
              local minor="${BASH_REMATCH[2]}"
              local patch="${BASH_REMATCH[3]}"
              echo "${major}.${minor}.$((patch + 1))"
            fi
          }

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          read -r -a services <<< "${{ steps.changed.outputs.services }}"
          for service in "${services[@]}"; do
            current_version="$(latest_semver_from_tag "$service")"
            version_source="tag"
            if [[ -z "$current_version" ]]; then
              current_version="$(latest_semver_from_s3 "$service")"
              version_source="s3-bootstrap"
            fi
            if [[ -z "$current_version" ]]; then
              echo "Unable to determine current version for ${service}. Create initial tag ${service}/vX.Y.Z or seed one artifact in S3." >&2
              exit 1
            fi

            version="$(bump_patch "$current_version")"
            if [[ -z "$version" ]]; then
              echo "Failed to bump version for ${service} from current version ${current_version}." >&2
              exit 1
            fi
            tag_name="${service}/v${version}"

            if git rev-parse -q --verify "refs/tags/${tag_name}" >/dev/null; then
              echo "Tag ${tag_name} already exists; refusing to overwrite." >&2
              exit 1
            fi

            echo "Publishing service=${service} version=${version} (source=${version_source})"
            DXCP_ARTIFACT_BUCKET="$DXCP_ARTIFACT_BUCKET" bash scripts/publish_build.sh "$service" "$version"

            artifact_uri="s3://${DXCP_ARTIFACT_BUCKET}/${service}/${service}-${version}.zip"
            printf "%s\t%s\t%s\n" "$service" "$version" "$artifact_uri" >> "$published_manifest"
            git tag "$tag_name" "${GITHUB_SHA}"
            git push origin "$tag_name"
            echo "Published service=${service} version=${version} artifact=${artifact_uri}"
            {
              echo "- service: ${service}"
              echo "  version: ${version}"
              echo "  tag: ${tag_name}"
              echo "  artifact: ${artifact_uri}"
            } >> "$GITHUB_STEP_SUMMARY"
          done
          echo "manifest=${published_manifest}" >> "$GITHUB_OUTPUT"

      - name: Register published builds in DXCP
        if: steps.changed.outputs.services != ''
        env:
          DXCP_API_BASE: ${{ vars.DXCP_API_BASE }}
          GOV_AUTH0_DOMAIN: ${{ vars.GOV_AUTH0_DOMAIN }}
          GOV_AUTH0_AUDIENCE: ${{ vars.GOV_AUTH0_AUDIENCE }}
          GOV_CI_CLIENT_ID: ${{ secrets.GOV_CI_CLIENT_ID }}
          GOV_CI_CLIENT_SECRET: ${{ secrets.GOV_CI_CLIENT_SECRET }}
        shell: bash
        run: |
          set -euo pipefail

          dxcp_base="${DXCP_API_BASE:-}"
          if [[ -z "$dxcp_base" ]]; then
            echo "Set repo variable DXCP_API_BASE to the DXCP API endpoint." >&2
            exit 1
          fi
          dxcp_base="${dxcp_base%/}"
          if [[ "$dxcp_base" != */v1 ]]; then
            dxcp_base="${dxcp_base}/v1"
          fi

          manifest_path="${{ steps.publish.outputs.manifest }}"
          if [[ -z "$manifest_path" || ! -s "$manifest_path" ]]; then
            echo "No published artifacts manifest found; nothing to register."
            exit 0
          fi

          for key in GOV_AUTH0_DOMAIN GOV_AUTH0_AUDIENCE GOV_CI_CLIENT_ID GOV_CI_CLIENT_SECRET; do
            if [[ -z "${!key:-}" ]]; then
              echo "Missing required CI identity setting: ${key}" >&2
              exit 1
            fi
          done

          token_response="$(curl -sS --fail --show-error -X POST "https://${GOV_AUTH0_DOMAIN}/oauth/token" \
            -H "Content-Type: application/json" \
            -d "{\"grant_type\":\"client_credentials\",\"audience\":\"${GOV_AUTH0_AUDIENCE}\",\"client_id\":\"${GOV_CI_CLIENT_ID}\",\"client_secret\":\"${GOV_CI_CLIENT_SECRET}\"}")"
          DXCP_API_TOKEN="$(python3 -c 'import json,sys; p=json.loads(sys.argv[1]); t=p.get("access_token", ""); assert t, "missing access_token"; print(t)' "${token_response}")"

          whoami="$(curl -sS --fail --show-error -H "Authorization: Bearer ${DXCP_API_TOKEN}" "${dxcp_base}/whoami")"
          echo "DXCP caller identity: ${whoami}"
          python3 -c 'import json,sys; i=json.loads(sys.argv[1]); cid=sys.argv[2]; aud=sys.argv[3]; dom=sys.argv[4]; iss=str(i.get("iss") or ""); azp=str(i.get("azp") or ""); sub=str(i.get("sub") or ""); av=i.get("aud"); exp=f"https://{dom.rstrip(\"/\")}/"; ok=(aud in av) if isinstance(av,list) else (str(av)==aud); exp_sub=f"{cid}@clients"; assert iss==exp, f"Unexpected issuer {iss!r} != {exp!r}"; assert ok, f"Expected audience {aud!r}, got {av!r}"; assert azp==cid, f"Expected azp {cid!r}, got {azp!r}"; assert exp_sub in sub, f"Expected sub to contain {exp_sub!r}, got {sub!r}"' "${whoami}" "${GOV_CI_CLIENT_ID}" "${GOV_AUTH0_AUDIENCE}" "${GOV_AUTH0_DOMAIN}"

          {
            echo "### DXCP CI identity"
            echo '```json'
            echo "${whoami}"
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

          while IFS=$'\t' read -r service version artifact_ref; do
            [[ -z "$service" || -z "$version" || -z "$artifact_ref" ]] && continue
            built_at="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            idem_key="github-${{ github.run_id }}-${service}-${version}"
            commit_url="${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
            run_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            payload_with_metadata="$(printf '{"service":"%s","version":"%s","artifactRef":"%s","git_sha":"%s","git_branch":"%s","ci_provider":"github","ci_run_id":"%s","built_at":"%s","commit_url":"%s","run_url":"%s"}' \
              "$service" "$version" "$artifact_ref" "${{ github.sha }}" "${{ github.ref_name }}" "${{ github.run_id }}" "$built_at" "$commit_url" "$run_url")"
            payload_without_metadata="$(printf '{"service":"%s","version":"%s","artifactRef":"%s","git_sha":"%s","git_branch":"%s","ci_provider":"github","ci_run_id":"%s","built_at":"%s"}' \
              "$service" "$version" "$artifact_ref" "${{ github.sha }}" "${{ github.ref_name }}" "${{ github.run_id }}" "$built_at")"
            body_file="${RUNNER_TEMP}/register-${service}-${version}.json"
            headers_file="${RUNNER_TEMP}/register-${service}-${version}.headers"
            status="$(curl -sS --show-error -X POST "${dxcp_base}/builds/register" \
              -H "Authorization: Bearer ${DXCP_API_TOKEN}" \
              -H "Content-Type: application/json" \
              -H "Idempotency-Key: ${idem_key}" \
              -d "${payload_with_metadata}" \
              -D "${headers_file}" \
              -o "${body_file}" \
              -w "%{http_code}")"
            metadata_mode="with_metadata"
            if [[ "${status}" == "400" ]]; then
              code="$(python3 -c 'import json,sys; p=json.load(open(sys.argv[1], "r", encoding="utf-8")); print(p.get("code",""))' "${body_file}" 2>/dev/null || true)"
              if [[ "${code}" == "INVALID_REQUEST" ]]; then
                status="$(curl -sS --show-error -X POST "${dxcp_base}/builds/register" \
                  -H "Authorization: Bearer ${DXCP_API_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -H "Idempotency-Key: ${idem_key}" \
                  -d "${payload_without_metadata}" \
                  -D "${headers_file}" \
                  -o "${body_file}" \
                  -w "%{http_code}")"
                metadata_mode="without_metadata"
              fi
            fi
            if [[ "${status}" != "201" && "${status}" != "200" ]]; then
              echo "Build registration failed status=${status}" >&2
              cat "${body_file}" >&2
              exit 1
            fi
            ci_publisher="$(python3 -c 'import json,sys; p=json.load(open(sys.argv[1], "r", encoding="utf-8")); cp=p.get("ci_publisher"); assert cp, "missing ci_publisher"; print(cp)' "${body_file}")"
            replayed="$(awk -F': ' 'tolower($1)=="idempotency-replayed" {print $2}' "${headers_file}" | tr -d '\r' | tail -n1)"
            replayed="${replayed:-missing}"
            echo "Registered build service=${service} version=${version} artifact=${artifact_ref} idempotency_key=${idem_key} ci_publisher=${ci_publisher} idempotency_replayed=${replayed} metadata_mode=${metadata_mode}"
            {
              echo "- registered: ${service}@${version}"
              echo "  artifact: ${artifact_ref}"
              echo "  ci_publisher: ${ci_publisher}"
              echo "  idempotency_replayed: ${replayed}"
              echo "  idempotency_key: ${idem_key}"
              echo "  metadata_mode: ${metadata_mode}"
              if [[ "${metadata_mode}" == "with_metadata" ]]; then
                echo "  commit_url: [Open commit](${commit_url})"
                echo "  run_url: [Open run](${run_url})"
              fi
            } >> "$GITHUB_STEP_SUMMARY"
          done < "$manifest_path"
